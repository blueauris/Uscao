From: <ÓÉ Microsoft Internet Explorer 5 ±£´æ>
Subject: Flood Fill
Date: Fri, 23 Jan 2009 17:05:49 +0800
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_0017_01C97D7C.D6DC0550"
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.3350

This is a multi-part message in MIME format.

------=_NextPart_000_0017_01C97D7C.D6DC0550
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://ace.delos.com/usacotext2?a=plV61TMMIka&S=flood

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Flood Fill</TITLE>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 6.00.2900.3492" name=3DGENERATOR></HEAD>
<BODY bgColor=3D#f0f0f0><FONT=20
face=3D"Verdana,Tahoma,sans-serif,Arial,Lucida Sans,Gill Sans">
<DIV=20
style=3D"BORDER-RIGHT: 1px solid; PADDING-RIGHT: 1em; BORDER-TOP: 1px =
solid; PADDING-LEFT: 1em; PADDING-BOTTOM: 1em; BORDER-LEFT: 1px solid; =
WIDTH: 45em; PADDING-TOP: 1em; BORDER-BOTTOM: 1px solid; =
BACKGROUND-COLOR: white">
<TABLE cellSpacing=3D8>
  <TBODY>
  <TR>
    <TD><IMG src=3D"http://ace.delos.com/usaco/cowhead2.gif"></TD>
    <TD>&nbsp;&nbsp;&nbsp;</TD>
    <TD><B><FONT size=3D5><FONT=20
      face=3D"Verdana,Tahoma,sans-serif,Arial,Lucida Sans,Gill =
Sans">Flood Fill=20
      </FONT></B></FONT></TD></TR></TBODY></TABLE>
<H4>Sample Problem: Connected Fields</H4>
<P>Farmer John's fields are broken into fields, with paths between some =
of them.=20
Unfortunately, some fields are not reachable from other fields via the =
paths.=20
<P>Define a <I>superfield</I> is a collection of fields that are all =
reachable=20
from each other. Calculate the number of superfields.=20
<H4>The Abstraction</H4>
<P>Given: a undirected graph=20
<P>The <I>component</I> of a graph is a maximal-sized (though not =
necessarily=20
maximum) subgraph which is connected.=20
<P>Calculate the component of the graph. <BR><IMG=20
src=3D"http://ace.delos.com/usaco/TEXT/flood1.gif"><BR>This graph has =
three=20
components: {1,4,8}, {2,5,6,7,9}, and {3}.=20
<H4>The Algorithm: Flood Fill</H4>
<P>Flood fill can be performed three basic ways: depth-first, =
breadth-first, and=20
breadth-first scanning. The basic idea is to find some node which has =
not been=20
assigned to a component and to calculate the component which contains. =
The=20
question is how to calculate the component.=20
<P>In the depth-first formulation, the algorithm looks at each step =
through all=20
of the neighbors of the current node, and, for those that have not been =
assigned=20
to a component yet, assigns them to this component and recurses on them. =

<P>In the breadth-first formulation, instead of recursing on the newly =
assigned=20
nodes, they are added to a queue.=20
<P>In the breadth-first scanning formulation, every node has two values: =

component and visited. When calculating the component, the algorithm =
goes=20
through all of the nodes that have been assigned to that component but =
not=20
visited yet, and assigns their neighbors to the current component.=20
<P>The depth-first formulation is the easiest to code and debug, but can =
require=20
a stack as big as the original graph. For explicit graphs, this is not =
so bad,=20
but for implicit graphs, such as the problem presented has, the numbers =
of nodes=20
can be very large.=20
<P>The breadth-formulation does a little better, as the queue is much =
more=20
efficient than the run-time stack is, but can still run into the same =
problem.=20
Both the depth-first and breadth-first formulations run in N + M time, =
where N=20
is the number of vertices and M is the number of edges.=20
<P>The breadth-first scanning formulation, however, requires very little =
extra=20
space. In fact, being a little tricky, it requires no extra space. =
However, it=20
is slower, requiring up to N*N + M time, where N is the number of =
vertices in=20
the graph.=20
<H4>Pseudocode for Breadth-First Scanning</H4>
<P>This code uses a trick to not use extra space, marking nodes to be =
visited as=20
in component -2 and actually assigning them to the current component =
when they=20
are actually visited. <BR><TT><FONT=20
size=3D2><BR>#&nbsp;component(i)&nbsp;denotes&nbsp;the<BR>#&nbsp;componen=
t&nbsp;that&nbsp;node&nbsp;i&nbsp;is&nbsp;in<BR>&nbsp;1&nbsp;function&nbs=
p;flood_fill(new_component)&nbsp;<BR><BR>&nbsp;2&nbsp;do<BR>&nbsp;3&nbsp;=
&nbsp;&nbsp;num_visited&nbsp;=3D&nbsp;0<BR>&nbsp;4&nbsp;&nbsp;&nbsp;for&n=
bsp;all&nbsp;nodes&nbsp;i<BR>&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp=
;component(i)&nbsp;=3D&nbsp;-2<BR>&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n=
bsp;&nbsp;num_visited&nbsp;=3D&nbsp;num_visited&nbsp;+&nbsp;1<BR>&nbsp;7&=
nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component(i)&nbsp;=3D&nbsp;new_c=
omponent<BR>&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;all=
&nbsp;neighbors&nbsp;j&nbsp;of&nbsp;node&nbsp;i<BR>&nbsp;9&nbsp;&nbsp;&nb=
sp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;component(j)&nbsp;=3D&nbsp=
;nil<BR>10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb=
sp;component(j)&nbsp;=3D&nbsp;-2<BR>11&nbsp;until&nbsp;num_visited&nbsp;=3D=
&nbsp;0&nbsp;<BR><BR>12&nbsp;function&nbsp;find_components&nbsp;<BR><BR>1=
3&nbsp;&nbsp;num_components&nbsp;=3D&nbsp;0<BR>14&nbsp;&nbsp;for&nbsp;all=
&nbsp;nodes&nbsp;i<BR>15&nbsp;&nbsp;&nbsp;&nbsp;component(node&nbsp;i)&nb=
sp;=3D&nbsp;nil<BR>16&nbsp;&nbsp;for&nbsp;all&nbsp;nodes&nbsp;i<BR>17&nbs=
p;&nbsp;&nbsp;&nbsp;if&nbsp;component(node&nbsp;i)&nbsp;is&nbsp;nil<BR>18=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_components&nbsp;=3D<BR>&nbsp;&nbs=
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp=
;&nbsp;&nbsp;&nbsp;num_components&nbsp;+&nbsp;1<BR>19&nbsp;&nbsp;&nbsp;&n=
bsp;&nbsp;&nbsp;component(i)&nbsp;=3D&nbsp;-2<BR>20&nbsp;&nbsp;&nbsp;&nbs=
p;&nbsp;&nbsp;flood_fill(component<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp=
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_components)<BR></FONT></TT>
<P>Running time of this algorithm is O(<I>N <SUP>2</SUP></I>), where =
<I>N</I> is=20
the numbers of nodes. Every edge is traversed twice (once for each =
end-point),=20
and each node is only marked once.=20
<H4>Execution Example</H4>
<P>Consider the graph from above. <BR><IMG=20
src=3D"http://ace.delos.com/usaco/TEXT/flood1.gif"><BR>
<P>The algorithm starts with all nodes assigned to no component.=20
<P>Going through the nodes in order first node not assigned to any =
component yet=20
is vertex 1. Start a new component (component 1) for that node, and set =
the=20
component of node 1 to -2 (any nodes not shown are unassigned).=20
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD align=3Dmiddle>Node</TD>
    <TD align=3Dmiddle>Component</TD></TR>
  <TR>
    <TD align=3Dmiddle><B>1</B></TD>
    <TD align=3Dmiddle><B>-2</B></TD></TR></TBODY></TABLE></CENTER>
<P>Now, in the <TT>flood_fill</TT> code, the first time through the =
<TT>do</TT>=20
loop, it finds the node 1 is assigned to component -2. Thus, it =
reassigns it to=20
component 1, signifying that it has been visited, and then assigns its =
neighbors=20
(node 4) to component -2.=20
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD align=3Dmiddle>Node</TD>
    <TD align=3Dmiddle>Component</TD></TR>
  <TR>
    <TD align=3Dmiddle><B>1</B></TD>
    <TD align=3Dmiddle><B>1</B></TD></TR>
  <TR>
    <TD align=3Dmiddle><B>4</B></TD>
    <TD align=3Dmiddle><B>-2</B></TD></TR></TBODY></TABLE></CENTER>
<P>As the loop through all the nodes continues, it finds that node 4 is =
also=20
assigned to component -2, and processes it appropriately as well.=20
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD align=3Dmiddle>Node</TD>
    <TD align=3Dmiddle>Component</TD></TR>
  <TR>
    <TD align=3Dmiddle>1</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle><B>4</B></TD>
    <TD align=3Dmiddle><B>1</B></TD></TR>
  <TR>
    <TD align=3Dmiddle><B>8</B></TD>
    <TD align=3Dmiddle><B>-2</B></TD></TR></TBODY></TABLE></CENTER>
<P>Node 8 is the next to be processed.=20
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD align=3Dmiddle>Node</TD>
    <TD align=3Dmiddle>Component</TD></TR>
  <TR>
    <TD align=3Dmiddle>1</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>4</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle><B>8</B></TD>
    <TD align=3Dmiddle><B>1</B></TD></TR></TBODY></TABLE></CENTER>
<P>Now, the <TT>for</TT> loop continues, and finds no more nodes that =
have not=20
been assigned yet. Since the <TT>until</TT> clause is not satisfied (=20
<TT>num_visited</TT> =3D 3), it tries again. This time, no nodes are =
found, so the=20
function exits and component 1 is complete.=20
<P>The search for unassigned nodes continues, finding node 2. A new =
component=20
(component 2) is allocated, node 2 is marked as in component -2, and=20
<TT>flood_fill</TT> is called.=20
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD align=3Dmiddle>Node</TD>
    <TD align=3Dmiddle>Component</TD></TR>
  <TR>
    <TD align=3Dmiddle>1</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle><B>2</B></TD>
    <TD align=3Dmiddle><B>-2</B></TD></TR>
  <TR>
    <TD align=3Dmiddle>4</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>8</TD>
    <TD align=3Dmiddle>1</TD></TR></TBODY></TABLE></CENTER>
<P>Node 2 is found as marked in component -2, and is processed.=20
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD align=3Dmiddle>Node</TD>
    <TD align=3Dmiddle>Component</TD></TR>
  <TR>
    <TD align=3Dmiddle>1</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>2</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>4</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle><B>7</B></TD>
    <TD align=3Dmiddle><B>-2</B></TD></TR>
  <TR>
    <TD align=3Dmiddle>8</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle><B>9</B></TD>
    <TD align=3Dmiddle><B>-2</B></TD></TR></TBODY></TABLE></CENTER>
<P>Next, node 7 is processed.=20
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD align=3Dmiddle>Node</TD>
    <TD align=3Dmiddle>Component</TD></TR>
  <TR>
    <TD align=3Dmiddle>1</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>2</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>4</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle><B>5</B></TD>
    <TD align=3Dmiddle><B>-2</B></TD></TR>
  <TR>
    <TD align=3Dmiddle><B>7</B></TD>
    <TD align=3Dmiddle><B>2</B></TD></TR>
  <TR>
    <TD align=3Dmiddle>8</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>9</TD>
    <TD align=3Dmiddle>-2</TD></TR></TBODY></TABLE></CENTER>
<P>Then node 9 is processed.=20
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD align=3Dmiddle>Node</TD>
    <TD align=3Dmiddle>Component</TD></TR>
  <TR>
    <TD align=3Dmiddle>1</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>2</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>4</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>5</TD>
    <TD align=3Dmiddle>-2</TD></TR>
  <TR>
    <TD align=3Dmiddle>7</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>8</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle><B>9</B></TD>
    <TD align=3Dmiddle><B>2</B></TD></TR></TBODY></TABLE></CENTER>
<P>The terminating condition does not hold ( <TT>num_visited</TT> =3D =
3), so the=20
search through for nodes assigned to component -2 starts again. Node 5 =
is the=20
first one found.=20
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD align=3Dmiddle>Node</TD>
    <TD align=3Dmiddle>Component</TD></TR>
  <TR>
    <TD align=3Dmiddle>1</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>2</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>4</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>5</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle><B>6</B></TD>
    <TD align=3Dmiddle><B>-2</B></TD></TR>
  <TR>
    <TD align=3Dmiddle>7</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>8</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>9</TD>
    <TD align=3Dmiddle>2</TD></TR></TBODY></TABLE></CENTER>
<P>Node 6 is the next node found to be in component -2.=20
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD align=3Dmiddle>Node</TD>
    <TD align=3Dmiddle>Component</TD></TR>
  <TR>
    <TD align=3Dmiddle>1</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>2</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>4</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>5</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle><B>6</B></TD>
    <TD align=3Dmiddle><B>2</B></TD></TR>
  <TR>
    <TD align=3Dmiddle>7</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>8</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>9</TD>
    <TD align=3Dmiddle>2</TD></TR></TBODY></TABLE></CENTER>
<P>No more nodes are found assigned to component -2, but the terminating =

condition does not hold, so one more pass through the nodes is =
performed,=20
finding no nodes assigned to component -2. Thus, the search for =
unassigned nodes=20
continue from node 2, finding node 3 unassigned.=20
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD align=3Dmiddle>Node</TD>
    <TD align=3Dmiddle>Component</TD></TR>
  <TR>
    <TD align=3Dmiddle>1</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>2</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle><B>3</B></TD>
    <TD align=3Dmiddle><B>-2</B></TD></TR>
  <TR>
    <TD align=3Dmiddle>4</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>5</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>6</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>7</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>8</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>9</TD>
    <TD align=3Dmiddle>2</TD></TR></TBODY></TABLE></CENTER>
<P>Node 3 is processed.=20
<CENTER>
<TABLE border=3D1>
  <TBODY>
  <TR>
    <TD align=3Dmiddle>Node</TD>
    <TD align=3Dmiddle>Component</TD></TR>
  <TR>
    <TD align=3Dmiddle>1</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>2</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>3</TD>
    <TD align=3Dmiddle>3</TD></TR>
  <TR>
    <TD align=3Dmiddle>4</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>5</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>6</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>7</TD>
    <TD align=3Dmiddle>2</TD></TR>
  <TR>
    <TD align=3Dmiddle>8</TD>
    <TD align=3Dmiddle>1</TD></TR>
  <TR>
    <TD align=3Dmiddle>9</TD>
    <TD align=3Dmiddle>2</TD></TR></TBODY></TABLE></CENTER>
<P>From here, the algorithm eventually terminates, as there are no more =
nodes=20
assigned to component -2 and no unassigned nodes. The three components =
of the=20
graph have been determined, along with the component to which each node =
belongs.=20

<H4>Problem Cues</H4>
<P>Generally, these types of problem are fairly clear. If it asks for =
sets of=20
"connected" things, it's probably asking for components, in which case =
flood=20
fill works very well. Often, this is a step in solving the complete =
problem.=20
<H4>Extensions</H4>
<P>The notion of ``components'' becomes muddied when you go to directed =
graphs.=20
<P>However, the same flooding idea can be used to determine the points =
which are=20
reachable from any given point even in a directed graph. At each =
recursive step,=20
if the point isn't marked already, mark the point as reachable and =
recurse on=20
all of its neighbors.=20
<P>Note that to determine which points can reach a given point in a =
directed=20
graph can be solved the same, by looking at every arc backwards.=20
<H4>Sample Problems</H4>
<H5>Company Ownership [abridged, IOI 93]</H5>
<P>Given: A weighted directed graph, with weights between 0 and 100.=20
<P>Some vertex A ``owns'' another vertex B if:=20
<UL>
  <LI>A =3D B=20
  <LI>There is an arc from A to B with weight more than 50.=20
  <LI>There exists some set of vertices <I>C <SUB>1</SUB></I> through =
<I>C=20
  <SUB>k</SUB></I> such that A owns <I>C <SUB>1</SUB></I> through <I>C=20
  <SUB>k</SUB></I>, and each vertex has an arc of weight <I>x =
<SUB>1</SUB></I>=20
  through <I>x <SUB>k</SUB></I> to vertex B, and <I>x <SUB>1</SUB></I> + =
<I>x=20
  <SUB>2</SUB></I> + ... + <I>x <SUB>k</SUB></I> &gt; 50. </LI></UL>
<P>Find all (a,b) pairs such that a owns b.=20
<P>Analysis: This can be solved via an adaptation of the calculating the =

vertices reachable from a vertex in a directed graph. To calculate which =

vertices vertex A owns, keep track of the ``ownership percentage'' for =
each=20
node. Initialize them all to zero. Now, at each recursive step, mark the =
node as=20
owned by vertex A and add the weight of all outgoing arcs to the =
``ownership=20
percentages.'' For all percentages that go above 50, recurse into those=20
vertices.=20
<H4>Street Race [IOI 95]</H4>
<P>Given: a directed graph, and a start point and an end point.=20
<P>Find all points p that any path from the start point to the end must =
travel=20
through p.=20
<P>Analysis: The easiest algorithm is to remove each point in turn, and =
check to=20
see if the end point is reachable from the start point. This runs in O(N =
(M +=20
N)) time. Since the original problem stated that M &lt;=3D 100, and N =
&lt;=3D 50,=20
this will run in time easily.=20
<H4>Cow Tours [1999 USACO National Championship, abridged]</H4>
<P>The diameter of a connected graph is defined as the maximum distance =
between=20
any two nodes of the graph, where the distance between two nodes is =
defined as=20
the length of the shortest path.=20
<P>Given a set of points in the plane, and the connections between those =
points,=20
find the two points which are currently not in the same component, such =
that the=20
diameter of the resulting component is minimized.=20
<P>Analysis: Find the components of the original graph, using the method =

described above. Then, for each pair of points not in the same =
component, try=20
placing a connection between them. Find the pair that minimizes the =
diameter.=20
<H4>Connected Fields</H4>
<P>Farmer John contracted out the building of a new barn. Unfortunately, =
the=20
builder mixed up the plans of Farmer John's barn with another set of =
plans.=20
Farmer John's plans called for a barn that only had one room, but the =
building=20
he got might have many rooms. Given a grid of the layout of the barn, =
tell=20
Farmer John how many rooms it has.=20
<P>Analysis: The graph here is on the non-wall grid locations, with edge =
between=20
adjacent non-wall locations, although the graph should be stored as the =
grid,=20
and not transformed into some other form, as the grid is so compact and =
easy to=20
work with. </P></DIV><BR>
<CENTER><A href=3D"http://ace.delos.com/usacogate?a=3DplV61TMMIka">USACO =
Gateway</A>=20
| <A href=3D"mailto:kolstad@ace.delos.com">Comment or Question</A>=20
</CENTER></FONT></BODY></HTML>

------=_NextPart_000_0017_01C97D7C.D6DC0550
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: http://ace.delos.com/usaco/cowhead2.gif

R0lGODlhQQBRAPYAAP///wgICBAQEBgYGM7Ozvfv7//39/8AALWEa4RSAP/3nP/vABAQGAgIEL21
xjkxQtbO3s7G1rWtvTEpOSkhMca9zkI5SiEYKVpKY2NSa1JCWko5UoxzlHNae2tSc5x7pbWUva2M
taWErb2UxpRznPfO/9at3saczt6t57WMvffG/9al3v/3/87GztbO1t7W3ufe5721va2lrbWttca9
xpSMlJyUnKWcpf/v/9bG1r2tvc69zrWltf/n///e/zkxOTEpMf/W/1pKWoRrhK2MrSkhKVJCUntj
e//O/86lzvfG96WEpZx7nHNac72Uvee155RzlLWMtUo5SmtSa4xrjK2ErYRjhGNKY0IxQqV7pVpC
WntaeyEYITkpOVI5UjEhMRgQGCkYKRAIEAgACPe97wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5
BAEAAAcALAAAAABBAFEAAAf+gAeCg4SFhoeIiYJlio2Oj5AHZZOTkZaXiJRlCQmbnZigkZqdm56k
oZiaqpScrZ2cpqWol5Otpq62sLaejLOirre4pby3vb6PsbjAr7rCx5DByrmkypXPjbXM0snb147R
1dPd3orgy9LO5Inm6O2f6ofs2u6w8Jnt8sLG9oPs+cD7+C1C9w+WLIH9CNKbFpBfMV4L5zWEp4mA
RQKq8KXztqrMxY8gMWajN5EWpQUoUy6oGBLkv5LQyqicSXNSy48jx6WSmXISSp4ra3q8iZGkyZ4/
eQJVOtPmTXkw4zVN+hNp0JVLifoTVbXrVaVMv/58ai5qIbBUv8r0Kfbqyqf++KBZbeuz7tqwa1vm
BCbXK967dP3q1Wftm8qwNBN3XTvW5bl3hucmXlVz8VCcBJEpTjoJgOfPnk9azeuYVKy+PSmBLgO6
NQC2gnEW1oQa6+pJCjp/1hTaK1aXvu5i3K2guHHWuI8jB9oT+CxKFlm/Pm48d/Xq0plzpnTsMnLl
Za7nTp5799TDMQv30wQ+/HVK2M1vXolNeuiJ8MeTL67KeGvtWPWUiX3/dfRaeOxhlyCByKUW3U/x
7BYAGGE0oNt/uyXYHoKudTTUWoboFoQKJJJ4m2oF9reKayweSNtZAJQoIxC8oZihjCXy1mKHLKoX
AI4qBFEGjjpSAqSMF+7+6CKSDC4So4xIDHmkCkZOieOBSt43CZH3CQIGjl9aKeaRy2V5IJVAIrcI
Fk++RqKUY74J55VYtrjllkeGtogmcaYpJoFKloEFmmm+FqKcc06pCplmgmalmmdRWeWjqxTaqKOF
NjTkopRyimSWOn7GJQCHSpqoopN+uluH2QH6JKSEnNrnn6v1uCKrpc7aJ4Ydhqgbd7nqSuuqPaIi
q7B01tnrc8g+et+OZn3T7JTK4trdtES6mqGhz+DZbJIF7kZOqmOCy+uB6ix3LKKB2gcsRyfCaaOd
gL57jbYuNgrui+Oae6m2/FLkL722qifQvD1Cay9CkiCsisLRClxkqCc9MhwhqwivZrGvGGcs7sax
FpzkhRGnKzKD7oIMI8bx6qlyP/p6+DLMoKoy81n4LnxziCnuDI2WPotisDqBAAA7

------=_NextPart_000_0017_01C97D7C.D6DC0550
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: http://ace.delos.com/usaco/TEXT/flood1.gif

R0lGODdh7wDnAIAAAAAAAP///ywAAAAA7wDnAAAC/oyPqcvtD6OctNqLs968+w+G4kiW5omm6sq2
7gvH8kzX9o3n+s73/g8MCofEovGITCqXzKbzCY1Kp9Sq9YrNaiEAwPYL7Iq94HJuLGZ0zewVeq0g
k9v00RuurutF9wZ+D7jx5vcXaHgxxjV3yEiy2AjpURhJaZFYiZmpucnZ6fkJGio6SlpqeoqaqrrK
2ur6ChsrO0tba/s0eKv1GJCre1V4x/sr9ShMDJxwjFzF68s8NYwG3exnMEzNhN17nR2VtjC37f2N
ME6Oa46efHC+vmT8TuUsXxxeDyWNn36/34Ttzl8YawKTbAtYkMc4hAnPPGDY0IY7iBFnTKwoJCBF
/owwNHL8gXDjRzcSRI5MwdDkSRMQVa60U8HlSxAUZc78UPMmjY02dWoQ2dMnoqFCXZgMWnSCSqSi
wBlxybRSsGlPf8qa1KdqhqiNJvV6NkQm10OX2oHNyGFsIDmLshaxqRaQOGVl33aIq2duHCVB8dKB
o88gTgp+I9Td4VQZPElKC3O55tjRYsZfE0OOXFIwX5pnvWA2rDm0pGdybnzmMxmnL70oLXdLfSSq
27N2qLb7t5mzbXUo3ObLrdsrt96zD9sF/s23k9OocQkTDjv2v6nGcSN/63o4dG3Rg2S/nYV5CPGI
visO3/3M9r27uKtf3699+o7wCW4hT9Oi+cxg/vAPfrEfYWb4R5kK1W3FBoF3taaWgh25V1t9CLbh
oFXjSShIHRVaKEiA+WkIYXnMbSgDiRjw5KFke5hIlGEYqrhiiOGkiNJaMpplIoslhnigRWRN96JR
jOjYWJAAdhUbHkSCN2RYri05HJIgbQcllD4iluKSVl5pWpBEbslliTSy55BUYvaUoyan9dhiDWBK
ZKCR/LnJCV5sLgjnJmONmVaeeqomZ4Y7eQJXoAXG8GaZlvDJ0o6f1GRoCfglqoNGjLJAHqWVOnDp
kZ6C4kyniH4KKo5JRmpJNHfeJWoLltEGkz2QSdqqkK9dtmqf7ATH5EC3LiMpeqMF5l1iwMaK/oVY
+1GKFayHVnMihm96ZsxuzSUbh7W5nudrlLwFK585VNU6ba8G3jejswJmhGqbAyo3YSSaOgKvuz+u
OK5YlMxLq7GB8nsuJKHmJKXAhChVsLycwgdwo5lMBF3DMGKSErEx1knYHxJf+2dMa2z8IaHRyhXK
UrXe2MlSl5UBMp3uthuWKUelu2spQC3ccnwyp6pIOaoQ7GLLOW+6bsYND41Y0Ytq5UpKHZYLi9Os
VjlLSBcqRItHfMD8X9aP9TuoLRcRN6ou52B2Ms+/LGQU1w8xwzZ9DsPN6ZnI0p3HTm4jbR2ZbsKF
DkCV/vuOxe8pHbjfCmktDz3FVpt2LPEQjJGGut60hcSx9bCGneXZcD74c/UWfit9zz3k+eXe0nv6
VtbukzohrScVrbqi67htLbeP3gNgfAP5emhun6I5cMMTH7xBbBUe+XvH084x9INLvzj11l+Pffba
Z/v89jF5L9HvBeUOPkvij19+2OnLvT6m5LcPf/zyz09//fbfj3/++u/Pf//+/w9AUxQAADs=

------=_NextPart_000_0017_01C97D7C.D6DC0550--
